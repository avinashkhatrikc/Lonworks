//{{NodeBuilder Code Wizard Start <CodeWizard Timestamp>
// Run on Mon Aug 12 13:56:34 2024, version 4.40.15
//
//}}NodeBuilder Code Wizard End
//{{NodeBuilder Code Wizard Start <CodeWizard Template>
//// <Template Revision="3"/>
//}}NodeBuilder Code Wizard End
//////////////////////////////////////////////////////////////////////////////
// File: msgtest.nc
//
//
// Generated by NodeBuilder Code Wizard Version 4.40.15
// Copyright (c) 2001-2014 Echelon Corporation.  All rights reserved.
//
// ECHELON MAKES NO REPRESENTATION, WARRANTY, OR CONDITION OF
// ANY KIND, EXPRESS, IMPLIED, STATUTORY, OR OTHERWISE OR IN
// ANY COMMUNICATION WITH YOU, INCLUDING, BUT NOT LIMITED TO,
// ANY IMPLIED WARRANTIES OF MERCHANTABILITY, SATISFACTORY
// QUALITY, FITNESS FOR ANY PARTICULAR PURPOSE,
// NONINFRINGEMENT, AND THEIR EQUIVALENTS.
//
//
// Written By:   
//
// Description:
//
// msgtest.nc is the device's main Neuron C source file, which
// automatically includes other application-specific Neuron C source or header
// files as necessary. The msgtest.nc file also contains the
// system tasks (when(reset), etc), network variables and the file directory.
//
//////////////////////////////////////////////////////////////////////////////

#ifndef _msgtest_NC_
#define _msgtest_NC_

#define _CODEWIZARD_VERSION_3_TEMPLATES_

#pragma specify_io_clock "10 MHz" 

//Lamp devices
#define LAMP_ON 3
#define LAMP_OFF 2
#define OFF 0
#define ON 1


//I/O declaration
IO_2 output bit ioLed1;


//Switch devices
IO_9 input  bit ioSwitch1;




#include <io_types.h>
//#define C_TO_K 2740
//IO_7 input ontime invert clock(2) io_temperature_sensor; 
//network output SNVT_temp nvoCurrentTemp;

IO_7  input pulsecount ioMic; //totalcount
IO_8 sci baud(SCI_115200) iosci;


char szRxBufA[50];
char szRxBufB[50];
unsigned short rx_count;
int bufTog;

//io_type audio_in = io_assign(analog_input, IO_7);

msg_tag TAG_OUT;

void displayNeuronIdOnLcd(void);
void setNodeId(void);

// Function declaration
void processRxData(char buffer[50], unsigned short rx_count);

//IO_9 input  bit ioSwitch1;
//msg_tag bind_info(nonbind) message;	
//msg_tag bind_info(nonbind) TAG_OUT;
/////////////////////////////////////////////////////////////////////////////
// Connect with the Code Wizard library.
//
// Version 3 of these templates, released with NodeBuilder 4, introduce
// versioning to the CodeWizard library by name. While version 1 didn't use
// any library, version 2 references CodeWizard.lib. This release of the
// templates, revision 3, references CodeWizard-3.lib, thus supporting
// co-existence of both template versions 2 and 3.
//
// The CodeWizard library supplies most of the utility functions defined in
// CodeWizard.h. Source code for this library is available in your
// NodeBuilder\Templates\CodeWizard\vX\LibSrc folder within your local
// LonWorks folder, where 'vX' is v2 or v3 (v4, etc, in future versions),
// subject to  the revision number of this application framework template.
// The revision number of this application framework template can be found
// at the top of this file.
//
// By default, CodeWizard-3.lib will be pre-installed into your LonWorks\images
// folder, and can be referenced with the pragma library "$IMG$\CodeWizard-3.lib"
// directive.
// User-defined versions of CodeWizard-3.lib should be located elsewhere. Define
// the USER_DEFINED_CODEWIZARD_LIB macro in this case, and reference your own
// version of CodeWizard-3.lib through the NodeBuilder project manager or the
// pragma library directive. See Readme.txt in the library source code folder
// for considerations and instructions regarding rebuilding of this library.
//
/////////////////////////////////////////////////////////////////////////////
#ifdef  _NEURONC
#   ifndef _MODEL_FILE
#       ifndef USER_DEFINED_CODEWIZARD_LIB
#           pragma library "$IMG$\CodeWizard-3.lib"
#       endif // USER_DEFINED_CODEWIZARD_LIB
#    endif // _MODEL_FILE
#endif  // _NEURONC

/////////////////////////////////////////////////////////////////////////////
// Header Files
//
#include "msgtest.h"
#include "common.h"
#include <addrdefs.h>
#include <msg_addr.h>
#include <access.h>
#include "msgdef.h"
#include <stddef.h> 


#define DOMAIN_ZERO 0
//
// The FileDirectory variable contains the file directory. Please see
// filexfer.h and filesys.h for more details about the implementation of the
// file system and the file transfer protocol.
// Note a file directory must be defined whenever at least one configuration
// property is defined in a configuration property value file, or at least one
// user-defined file exists. A file directory must be defined independent of
// the CP access mechanism (file transfer or direct access).
// Note that a different layout of file directory will be compiled for each of
// these access methods. The two access methods are mutually exclusive.
//
#ifndef _USE_NO_CPARAMS_ACCESS
    DIRECTORY_STORAGE TFileDirectory FileDirectory = {
        FILE_DIRECTORY_VERSION,   // major and minor version number (one byte)
        NUM_FILES, {
#ifdef _USE_DIRECT_CPARAMS_ACCESS
            { cp_template_file_len,         TEMPLATE_TYPE,  cp_template_file },
            { cp_modifiable_value_file_len, VALUE_TYPE,     cp_modifiable_value_file },
            { cp_readonly_value_file_len,   VALUE_TYPE,     cp_readonly_value_file   }
#else   // def. _USE_FTP_CPARAMS_ACCESS
            { NULL_INFO, { 0ul, cp_template_file_len         },    TEMPLATE_TYPE, cp_template_file },
            { NULL_INFO, { 0ul, cp_modifiable_value_file_len },    VALUE_TYPE,    cp_modifiable_value_file },
            { NULL_INFO, { 0ul, cp_readonly_value_file_len   },    VALUE_TYPE,    cp_readonly_value_file }
#endif  // def. _USE_DIRECT_CPARAMS_ACCESS
        }
    };
#endif // def. _USE_NO_CPARAMS_ACCESS

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks
// between {{NodeBuilder Code Wizard Start and }}NodeBuilder Code Wizard End

//<Include Enum Type Headers>
//
//<Global CP Family Declarations>
//
//<Include Headers>
#include "NodeObject.h"
#include "analogMicInput.h"
//
//<Device CP Family Declarations>
//
//<Device CP Declarations>
//
//<Device Input NV Declarations>
//
//<Device Output NV Declarations>
//
// <Include NC>
#include "NodeObject.nc"
#include "analogMicInput.nc"
//
//}}NodeBuilder Code Wizard End


/////////////////////////////////////////////////////////////////////////////
// Neuron C Files
//
#include "common.nc"
#include "lcd.nc"
#include <analogMicInput.nc>
#ifdef _USE_FTP_CPARAMS_ACCESS
    #include "fileSys.nc"
    #include "fileXfer.nc"
#endif

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks!

//<Input NV>
//
//}}NodeBuilder Code Wizard End

//{{NodeBuilder Code Wizard Start
// The NodeBuilder Code Wizard will add and remove code here.
// DO NOT EDIT the NodeBuilder Code Wizard generated code in these blocks!

//<Input NV Define>
//
// The following code will be ignored if this Neuron C file is used without
// an input NV implemented.  The Code Wizard automatically enables 
// the _HAS_INP_DEV_NV macro if there is at least one input NV implemented.
//
#ifdef _HAS_INP_DEV_NV
//
//<Device NV When>
//
//}}NodeBuilder Code Wizard End
{
    // TODO: Add code to handle input network variable processing
}
#endif  //_HAS_INP_DEV_NV


//
// when(reset) executes when the device is reset. Make sure to keep
// your when(reset) task short, as a pending state change can not be
// confirmed until this task is completed.
// The executeOnEachFblock() function, which is part of the CodeWizard
// application framework and can be found in the common.nc source file,
// automatically re-triggers the watchdog timer with every 16th fblock, but
// time-consuming director implementations may require additional caution
// in this regard.
//


when(io_in_ready(iosci))
{
 // Switch to the other buffer and keep the RX count
 rx_count = sci_in_request_ex((bufTog) ? szRxBufA : szRxBufB, sizeof(szRxBufA));
 bufTog ^= 1; // toggle this
 
 // Do something with RX data using the filled data buffer. 
 // It may be only a few bytes, or it may be close to 50 bytes. 
 processRxData((bufTog) ? szRxBufA : szRxBufB, rx_count);
}


when (reset)
{	
	//char string[20];
	//unsigned long micValue;
    initAllFblockData(TOTAL_FBLOCK_COUNT);
    executeOnEachFblock(0, FBC_WHEN_RESET); 
    LCDReset();
    displayNeuronIdOnLcd();
    setNodeId();
    io_change_init(ioSwitch1);
    
    (void)io_in_request(iosci, szRxBufA, 50);
 	bufTog = 0;  // indicates that A is in use.
    //trying for getting analog data when Switch change state
	
	//micValue =io_in(ioMic);
	//bin2bcd(micValue, &digits);	
	//intToStr(micValue,string);
	//printDebug(string);
	//(void)strcpy(string,"I ioSwitch1");
	//printDebug(string);

	
    //welcomeScreen();
}


//  Periodic sampling of all inputs
#define TICKS_PER_SECOND    50u
mtimer repeating tTick = 1000ul / TICKS_PER_SECOND;
far unsigned OneSec = TICKS_PER_SECOND;
when(timer_expires(tTick))
{
	char string[25];
	unsigned long micValue;
	//unsigned data;
	
	
	micValue =io_in(ioMic);
	//bin2bcd(micValue, &digits);	
	intToStr(micValue,string);
	//printDebug(string);
	(void)strcpy(string,"\r\n");
	//printDebug(string);
	
}


/*
when(io_update_occurs(ioMic)){
char string[25];
unsigned long ticks;
ticks=input_value;
bin2bcd(ticks, &digits);	
intToStr(ticks,string);
printDebug(string);
(void)strcpy(string,"\r\n");
printDebug(string);
}

*/

/*
#define TICKS_PER_SECOND    50u
mtimer repeating tTick = 1000ul / TICKS_PER_SECOND;
far unsigned OneSec = TICKS_PER_SECOND;
when(timer_expires(tTick))
{
char string[20];
	ontime_t sensor_value;
	
	sensor_value=io_in(io_temperature_sensor);
	nvoCurrentTemp=(sensor_value * 221) / 642 
			+211 +C_TO_K;
	//bin2bcd(nvoCurrentTemp, &digits);
	intToStr(nvoCurrentTemp,string);
	printDebug(string);
	(void)strcpy(string,"\r\n");
	printDebug(string);
			
}
*/

//
// when(offline) executes as the device enters the offline state.
// Make sure to keep this task short, as the state change can
// not be confirmed until this task is completed.
//
when (offline)
{
    executeOnEachFblock(0, FBC_WHEN_OFFLINE);
}

//
// when(online) executes as the device enters the online state.
// Make sure to keep this task short, as the state change can
// not be confirmed until this task is completed.
//
when (online)
{
    executeOnEachFblock(0, FBC_WHEN_ONLINE);
}

//
// when(wink) executes as the device receives a wink command, and regardless
// of the device's current state. Add code here to implement your device's
// specific wink-behavior. Your code should trigger an appropriate action,
// such as the brief flashing of an LED or the sounding of a buzzer, allowing
// maintenance staff to identify the device in the field.
// Under no circumstances should wink cause an action that could engage users,
// machinery or maintenance staff.
// Remember the wink task also executes in the unconfigured state. Application
// timers and other features that require the configured state should not be
// used in the implementation of your when(wink) task.
///
when (wink)
{
    // TODO: Implement appropriate wink behavior here
}

when(io_changes(ioSwitch1)){

	
	
	
	
	
	msg_out.dest_addr.bcast.type = SUBNET_NODE;//either BROADCAST or SUBNET_NODE
	msg_out.dest_addr.bcast.domain = DOMAIN_ZERO;
	msg_out.dest_addr.bcast.rpt_timer = 10;
	msg_out.dest_addr.bcast.retry = 3;
	msg_out.dest_addr.bcast.tx_timer = 10;
	msg_out.dest_addr.bcast.backlog = 6;
	msg_out.dest_addr.bcast.subnet = 1;
	//msg_out.dest_addr.snode.node = 1;
	msg_out.priority_on = FALSE;
	msg_out.tag=TAG_OUT;
	msg_out.code= (input_value == ON) ? LAMP_ON : LAMP_OFF;
	msg_out.authenticated = FALSE;
	msg_out.service = ACKD;
	//memcpy(msg_out.data, read_only_data.neuron_id, NEURON_ID_LEN);
	//msg_out.data[0] = domain_copy.node;
	msg_send();
}




when(msg_arrives){
	//io_out (ioLed1,1);
	//char string[20];
	//(void)strcpy(string,"I am inside msg_arrives");
    //printDebug(string);
	switch(msg_in.code){
	case LAMP_ON:
	io_out(ioLed1,ON);
	break;
	case LAMP_OFF:
	io_out(ioLed1,OFF);
	break;
	case station_presence:   		
			temp = msg_in.data[0];						//Extract data
			msg_free();									//Free input buffer quickly
			if ((temp < max_stations) && (temp != domain_copy.node))	//Ignore stations with the same number
			{															//or stations outside valid number range
				stations[temp >> 3] |= (1 << (temp & 0b00000111));	//Set bit representing station
				*vbs_reg = 0x80;							//Select nvram
				if (directory_nvram->directory[temp].station_state == 0)				//If station not in directory
				{
					directory_nvram->directory[temp].station_state = 1;
				}
			}
			
			break;
	
	}//end switch
	
}//end when msg_arrives

#ifdef _HAS_CHANGEABLE_NV

//
// CodeWizard automatically defines the _HAS_CHANGEABLE_NV macro, if at least
// one network variable with changeable type is implemented. The conditionally
// compiled code here implements the system callback routine used to report
// the true and current length of a given network variable back to the system
// firmware.
// Code Wizard also enables the callback by inserting the
// system_image_extensions pragma, see msgtest.h.
// Note that callback support requires version 14 system firmware (or better).
//
unsigned _RESIDENT get_nv_length_override(unsigned nvIndex)
{
    unsigned uResult;

#ifdef _SUPPORT_LARGE_NV
    uResult = get_declared_nv_length(nvIndex);
#else
    // Assume no override
    uResult = 0xFF;
#endif

    // TO DO: add code to return the current length of the network variable
    // with index "nvIndex."
    // Example code follows:
    //
    // switch (nvIndex) {
    //     case nviChangeableNv::global_index:
    //         if (nviChangeableNv::cpNvType.type_category != NVT_CAT_INITIAL
    //          && nviChangeableNv::cpNvType.type_category != NVT_CAT_NUL) {
    //             uResult = nviChangeableNv::cpNvType.type_length;
    //         }
    //         break;
    // } // switch

    return uResult;
}

#endif  // #ifdef _HAS_CHANGEABLE_NV

void setNodeId(void)
{
	char string[20];
	char dial_number_id[3];
	//domain_copy = *(access_domain(1));
	unsigned char hint = read_only_data.neuron_id[NEURON_ID_LEN-1] & 0x1F;
    domain_copy.node = (dil_switch & 0b00011111);	//Make number equal to dil switch setting
	//update_domain(&domain_copy, 0);	
	
	//To print Node ID number
	//domain_copy = *(access_domain(0));
	dial_number=(dil_switch & 0b00011111);
	bin2bcd(dial_number, &digits);
	bin2bcd(hint, &digits);	
	intToStr(dial_number,dial_number_id);
	intToStr(hint,dial_number_id);
	
	(void)strcpy(string,"Node ID: ");
    LCDDisplayString(0,1,string);
	LCDDisplayString(0,10,dial_number_id);
	
	//To Broadcast node ID
	
	*vbs_reg = 0x80;							//Select nvram
	
	directory_nvram->directory[domain_copy.node].station_state = 1;				//Set own new id number

	msg_out.dest_addr.bcast.type = BROADCAST;//either BROADCAST or SUBNET_NODE
	msg_out.dest_addr.bcast.domain = DOMAIN_ZERO;
	msg_out.dest_addr.bcast.rpt_timer = 10;
	msg_out.dest_addr.bcast.retry = 3;
	msg_out.dest_addr.bcast.tx_timer = 10;
	msg_out.dest_addr.bcast.backlog = 6;
	msg_out.dest_addr.bcast.subnet = 1;
	msg_out.priority_on = FALSE;
	msg_out.tag=TAG_OUT;
	msg_out.code=station_presence;
	msg_out.authenticated = FALSE;
	msg_out.service = ACKD;
	//msg_out.data[0] = domain_copy.node;
	msg_out.data[0] = hint;
	msg_send();
}

void processRxData(char buffer[50], unsigned short rx_count)
{
 io_out_request(iosci, buffer, rx_count);
}


void byte_to_hex(unsigned char value, char* outputd)
{
    static const char hexChars[] = "0123456789ABCDEF";
    outputd[0] = hexChars[(value >> 4) & 0x0F];
    outputd[1] = hexChars[value & 0x0F];
}

void displayNeuronIdOnLcd(void)
{
    char buffer[20];
    char stringa[20];
    int i;

    for (i = 0; i < NEURON_ID_LEN; i++)
    {
        byte_to_hex(read_only_data.neuron_id[i], buffer + (i * 2));
    }

    buffer[12] = '\0'; // Null-terminate

    LCDReset();
    (void)strcpy(stringa,"Neuron ID: ");
    LCDDisplayString(0, 0, stringa);
    LCDDisplayString(1, 0, buffer);  // e.g., "0021C7AB12EF"
}




/*
void display_digits(void)
{
	display_data[data_bits] = 0b10000000;				//select dd ram address top left corner
	display_data[destination] = registers + aux_contacts;
	io_out(io_display, &display_data, display_length);

	if (digits.d5 != 0)
	{
		display_data[data_bits] = (digits.d5 + 0x30);	//Diplay tens digit only if non-zero
		display_data[destination] = display_ram + aux_contacts;
		io_out(io_display, &display_data, display_length);
	}
	display_data[data_bits] = (digits.d6 + 0x30);		//Display units digit
	display_data[destination] = display_ram + aux_contacts;
	io_out(io_display, &display_data, display_length);
	if (digits.d5 == 0)
	{													//If tens digit zero, leave space
		display_data[data_bits] = 0x20;
		display_data[destination] = display_ram + aux_contacts;
		io_out(io_display, &display_data, display_length);
	}
	display_data[data_bits] = 0x3A;						//Display colon
	display_data[destination] = display_ram + aux_contacts;
	io_out(io_display, &display_data, display_length);

	dial_number = bcd2bin(&digits);						//Convert BCD dialling number to binary
	if (station_valid(dial_number))						//If station exists
	{
		*vbs_reg = 0x80;				
		strcpy(string, &directory_nvram->directory[dial_number].station_name[0]);	//display station name
	}
	else
		get_rom_text(string, language, unused);		//display the word unused
	printltor(0x83, string);
}
*/
#endif // _msgtest_NC_
